---
sidebar: sidebar 
permalink: get-started/create-kubeconfig.html 
keywords: kubeconfig, create, config file, file, config 
summary: È necessario creare un file kubeconfig con ruolo di amministratore per i cluster autogestiti. 
---
= Creare un file kubeconfig
:hardbreaks:
:allow-uri-read: 
:icons: font
:imagesdir: ../media/get-started/


[role="lead"]
È possibile aggiungere un cluster ad Astra Control Service utilizzando un file kubeconfig. A seconda del tipo di cluster che si desidera aggiungere, potrebbe essere necessario creare manualmente un file kubeconfig per il cluster utilizzando passaggi specifici.

* <<Creare un file kubeconfig per i cluster Amazon EKS>>
* <<Creare un file kubeconfig per Red Hat OpenShift Service su cluster AWS (ROSA)>>
* <<Creare un file kubeconfig per altri tipi di cluster>>




== Creare un file kubeconfig per i cluster Amazon EKS

Segui queste istruzioni per creare un file kubeconfig e un token secret permanente per i cluster Amazon EKS. Per i cluster ospitati in EKS è necessario un token secret permanente.

.Fasi
. Seguire le istruzioni nella documentazione di Amazon per generare un file kubeconfig:
+
https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html["Creazione o aggiornamento di un file kubeconfig per un cluster Amazon EKS"^]

. Creare un account di servizio come segue:
+
.. Creare un file di account del servizio denominato `astracontrol-service-account.yaml`.
+
Modificare il nome dell'account di servizio in base alle necessità. Lo spazio dei nomi `kube-system` è necessario per questi passaggi. Se si modifica il nome dell'account di servizio, è necessario apportare le stesse modifiche nei seguenti passaggi.

+
[source, subs="specialcharacters,quotes"]
----
*astracontrol-service-account.yaml*
----
+
[source, yaml]
----
apiVersion: v1
kind: ServiceAccount
metadata:
  name: astra-admin-account
  namespace: kube-system
----


. Applicare l'account del servizio:
+
[source, console]
----
kubectl apply -f astracontrol-service-account.yaml
----
. Creare un `ClusterRoleBinding` file chiamato `astracontrol-clusterrolebinding.yaml`.
+
[source, subs="specialcharacters,quotes"]
----
*astracontrol-clusterrolebinding.yaml*
----
+
[source, yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: astra-admin-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: astra-admin-account
  namespace: kube-system
----
. Applicare l'associazione del ruolo del cluster:
+
[source, console]
----
kubectl apply -f astracontrol-clusterrolebinding.yaml
----
. Creare un file token secret dell'account di servizio chiamato `astracontrol-secret.yaml`.
+
[source, subs="specialcharacters,quotes"]
----
*astracontrol-secret.yaml*
----
+
[source, yaml]
----
apiVersion: v1
kind: Secret
metadata:
  annotations:
    kubernetes.io/service-account.name: astra-admin-account
  name: astra-admin-account
  namespace: kube-system
type: kubernetes.io/service-account-token
----
. Applicare il token secret:
+
[source, console]
----
kubectl apply -f astracontrol-secret.yaml
----
. Recuperare il token secret:
+
[source, console]
----
kubectl get secret astra-admin-account -n kube-system -o jsonpath='{.data.token}' | base64 -d
----
. Sostituire `user` Sezione del file kubeconfig AWS EKS con il token, come mostrato nell'esempio seguente:
+
[source, yaml]
----
user:
    token: k8s-aws-v1.aHR0cHM6Ly9zdHMudXMtd2VzdC0yLmFtYXpvbmF3cy5jb20vP0FjdGlvbj1HZXRDYWxsZXJJZGVudGl0eSZWZXJzaW9uPTIwMTEtMDYtMTUmWC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBM1JEWDdKU0haWU9LSEQ2SyUyRjIwMjMwNDAzJTJGdXMtd2VzdC0yJTJGc3RzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyMzA0MDNUMjA0MzQwWiZYLUFtei1FeHBpcmVzPTYwJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCUzQngtazhzLWF3cy1pZCZYLUFtei1TaWduYXR1cmU9YjU4ZWM0NzdiM2NkZGYxNGRhNzU4MGI2ZWQ2zY2NzI2YWIwM2UyNThjMjRhNTJjNmVhNjc4MTRlNjJkOTg2Mg
----




== Creare un file kubeconfig per Red Hat OpenShift Service su cluster AWS (ROSA)

Segui queste istruzioni per creare un file kubeconfig per Red Hat OpenShift Service su cluster AWS (ROSA).

.Fasi
. Accedere al cluster ROSA.
. Creare un account di servizio:
+
[source, console]
----
oc create sa astracontrol-service-account
----
. Aggiungere un ruolo cluster:
+
[source, console]
----
oc adm policy add-cluster-role-to-user cluster-admin -z astracontrol-service-account
----
. Utilizzando l'esempio seguente, creare un file di configurazione segreto dell'account di servizio:
+
[source, subs="specialcharacters,quotes"]
----
*secret-astra-sa.yaml*
----
+
[source, yaml]
----
apiVersion: v1
kind: Secret
metadata:
  name: secret-astracontrol-service-account
  annotations:
    kubernetes.io/service-account.name: "astracontrol-service-account"
type: kubernetes.io/service-account-token
----
. Creare il segreto:
+
[source, console]
----
oc create -f secret-astra-sa.yaml
----
. Modificare l'account di servizio creato e aggiungere il nome segreto dell'account del servizio Astra Control a. `secrets` sezione:
+
[source, console]
----
oc edit sa astracontrol-service-account
----
+
[source, yaml]
----
apiVersion: v1
imagePullSecrets:
- name: astracontrol-service-account-dockercfg-dvfcd
kind: ServiceAccount
metadata:
  creationTimestamp: "2023-08-04T04:18:30Z"
  name: astracontrol-service-account
  namespace: default
  resourceVersion: "169770"
  uid: 965fa151-923f-4fbd-9289-30cad15998ac
secrets:
- name: astracontrol-service-account-dockercfg-dvfcd
- name: secret-astracontrol-service-account ####ADD THIS ONLY####
----
. Elencare i segreti dell'account di servizio, sostituendo `<CONTEXT>` con il contesto corretto per l'installazione:
+
[source, console]
----
kubectl get serviceaccount astracontrol-service-account --context <CONTEXT> --namespace default -o json
----
+
La fine dell'output dovrebbe essere simile a quanto segue:

+
[listing]
----
"secrets": [
{ "name": "astracontrol-service-account-dockercfg-dvfcd"},
{ "name": "secret-astracontrol-service-account"}
]
----
+
Gli indici di ciascun elemento in `secrets` l'array inizia con 0. Nell'esempio precedente, l'indice per `astracontrol-service-account-dockercfg-dvfcd` sarebbe 0 e l'indice per `secret-astracontrol-service-account` sarebbe 1. Nell'output, annotare il numero dell'indice per il segreto dell'account del servizio. Questo numero di indice sarà necessario nella fase successiva.

. Generare il kubeconfig come segue:
+
.. Creare un `create-kubeconfig.sh` file. Sostituire `TOKEN_INDEX` all'inizio del seguente script con il valore corretto.
+
[source, subs="specialcharacters,quotes"]
----
*create-kubeconfig.sh*
----
+
[source, bash]
----
# Update these to match your environment.
# Replace TOKEN_INDEX with the correct value
# from the output in the previous step. If you
# didn't change anything else above, don't change
# anything else here.

SERVICE_ACCOUNT_NAME=astracontrol-service-account
NAMESPACE=default
NEW_CONTEXT=astracontrol
KUBECONFIG_FILE='kubeconfig-sa'

CONTEXT=$(kubectl config current-context)

SECRET_NAME=$(kubectl get serviceaccount ${SERVICE_ACCOUNT_NAME} \
  --context ${CONTEXT} \
  --namespace ${NAMESPACE} \
  -o jsonpath='{.secrets[TOKEN_INDEX].name}')
TOKEN_DATA=$(kubectl get secret ${SECRET_NAME} \
  --context ${CONTEXT} \
  --namespace ${NAMESPACE} \
  -o jsonpath='{.data.token}')

TOKEN=$(echo ${TOKEN_DATA} | base64 -d)

# Create dedicated kubeconfig
# Create a full copy
kubectl config view --raw > ${KUBECONFIG_FILE}.full.tmp

# Switch working context to correct context
kubectl --kubeconfig ${KUBECONFIG_FILE}.full.tmp config use-context ${CONTEXT}

# Minify
kubectl --kubeconfig ${KUBECONFIG_FILE}.full.tmp \
  config view --flatten --minify > ${KUBECONFIG_FILE}.tmp

# Rename context
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  rename-context ${CONTEXT} ${NEW_CONTEXT}

# Create token user
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  set-credentials ${CONTEXT}-${NAMESPACE}-token-user \
  --token ${TOKEN}

# Set context to use token user
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  set-context ${NEW_CONTEXT} --user ${CONTEXT}-${NAMESPACE}-token-user

# Set context to correct namespace
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  set-context ${NEW_CONTEXT} --namespace ${NAMESPACE}

# Flatten/minify kubeconfig
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  view --flatten --minify > ${KUBECONFIG_FILE}

# Remove tmp
rm ${KUBECONFIG_FILE}.full.tmp
rm ${KUBECONFIG_FILE}.tmp
----
.. Eseguire la sorgente dei comandi per applicarli al cluster Kubernetes.
+
[source, console]
----
source create-kubeconfig.sh
----


. (Facoltativo) rinominare il kubeconfig con un nome significativo per il cluster.
+
[listing]
----
mv kubeconfig-sa YOUR_CLUSTER_NAME_kubeconfig
----




== Creare un file kubeconfig per altri tipi di cluster

Seguire queste istruzioni per creare un file kubeconfig per i cluster Rancher, Kubernetes upstream e Red Hat OpenShift.

.Prima di iniziare
Prima di iniziare, assicurarsi di disporre di quanto segue sul computer:

* kubectl v1,26 o versione successiva installata
* Un kubeconfig attivo per il cluster che si intende gestire con i diritti di amministratore del cluster per il contesto attivo


.Fasi
. Creare un account di servizio:
+
.. Creare un file di account del servizio denominato `astracontrol-service-account.yaml`.
+
Regolare il nome e lo spazio dei nomi in base alle esigenze. Se le modifiche vengono apportate qui, è necessario applicare le stesse modifiche nei passaggi seguenti.

+
[source, subs="specialcharacters,quotes"]
----
*astracontrol-service-account.yaml*
----
+
[source, yaml]
----
apiVersion: v1
kind: ServiceAccount
metadata:
  name: astracontrol-service-account
  namespace: default
----
.. Applicare l'account del servizio:
+
[source, console]
----
kubectl apply -f astracontrol-service-account.yaml
----


. Creare uno dei seguenti ruoli del cluster con autorizzazioni sufficienti per la gestione di un cluster da parte di Astra Control:
+
** *Ruolo cluster limitato*: Questo ruolo contiene le autorizzazioni minime necessarie per la gestione di un cluster da parte di Astra Control:
+
.Espandere per i passaggi
[%collapsible]
====
... Creare un `ClusterRole` file chiamato, ad esempio, `astra-admin-account.yaml`.
+
Regolare il nome e lo spazio dei nomi in base alle esigenze. Se le modifiche vengono apportate qui, è necessario applicare le stesse modifiche nei passaggi seguenti.

+
[source, subs="specialcharacters,quotes"]
----
*astra-admin-account.yaml*
----
+
[source, yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: astra-admin-account
rules:

# Justification for resource permissions:

# Astra Control needs to be able to discover (list) resources of all types within your application.
# These permissions are required to discover, back up, and restore your application resources including
# secrets.
# For example, if your application contains custom resources or cluster-scoped resources, Astra Control
# needs '*' to discover, back up, and restore your application resources.

# Justification for Verbs:
# - "List" enables discovery.
# - "Get" enables resource backups and enables users to define apps using GVK.
# - "Create" enables restoring an application from a snapshot or backup using Astra Control.
# - "Delete" enables application resource clean-up as part of an in-place restore of an application or clones.
# - "Patch" enables maintaining owner references and updating labels on some resources.
# - "Update" enables replica scaling in case of operations like in-place restores of your application.
# - "Watch" enables Astra Control to keep an up to date view of resources.

# Manage all resources
# Necessary to back up and restore all resources in an app
- apiGroups:
  - '*'
  resources:
  - '*'
  verbs:
  - get
  - list
  - create
  - patch
  - delete
  - watch
  - update

- nonResourceURLs:
  - /metrics
  verbs:
  - get
  - watch
  - list

# Use PodSecurityPolicies
- apiGroups:
  - extensions
  - policy
  resources:
  - podsecuritypolicies
  verbs:
  - use

# OpenShift security - uncomment the following lines for Red Hat OpenShift clusters
#- apiGroups:
#  - security.openshift.io
#  resources:
#  - securitycontextconstraints
#  verbs:
#  - use
----
... (Solo per i cluster OpenShift) se si sta creando un kubeconfig per un cluster OpenShift, annullare il commento delle linee finali nel `astra-admin-account.yaml` file dopo il `# Use PodSecurityPolicies` sezione:
+
[source, console]
----
# OpenShift security
- apiGroups:
  - security.openshift.io
  resources:
  - securitycontextconstraints
  verbs:
  - use
----
... Applicare il ruolo del cluster:
+
[source, console]
----
kubectl apply -f astra-admin-account.yaml
----


====
** *Ruolo cluster esteso*: Questo ruolo contiene autorizzazioni estese per un cluster che deve essere gestito da Astra Control. È possibile utilizzare questo ruolo se si utilizzano più contesti e non è possibile utilizzare il kubeconfig di Astra Control predefinito configurato durante l'installazione oppure se un ruolo limitato con un singolo contesto non funziona nell'ambiente:
+

NOTE: Quanto segue `ClusterRole` I passaggi sono un esempio generale di Kubernetes. Consultare la documentazione della distribuzione Kubernetes per istruzioni specifiche sull'ambiente in uso.

+
.Espandere per i passaggi
[%collapsible]
====
... Creare un `ClusterRole` file chiamato, ad esempio, `astra-admin-account.yaml`.
+
Regolare il nome e lo spazio dei nomi in base alle esigenze. Se le modifiche vengono apportate qui, è necessario applicare le stesse modifiche nei passaggi seguenti.

+
[source, subs="specialcharacters,quotes"]
----
*astra-admin-account.yaml*
----
+
[source, yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: astra-admin-account
rules:
- apiGroups:
  - '*'
  resources:
  - '*'
  verbs:
  - '*'
- nonResourceURLs:
  - '*'
  verbs:
  - '*'
----
... Applicare il ruolo del cluster:
+
[source, console]
----
kubectl apply -f astra-admin-account.yaml
----


====


. Creare l'associazione del ruolo del cluster all'account del servizio per il ruolo del cluster:
+
.. Creare un `ClusterRoleBinding` file chiamato `astracontrol-clusterrolebinding.yaml`.
+
Modificare i nomi e gli spazi dei nomi modificati quando si crea l'account del servizio, in base alle necessità.

+
[source, subs="specialcharacters,quotes"]
----
*astracontrol-clusterrolebinding.yaml*
----
+
[source, yaml]
----
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: astracontrol-admin
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: astra-admin-account
subjects:
- kind: ServiceAccount
  name: astracontrol-service-account
  namespace: default
----
.. Applicare l'associazione del ruolo del cluster:
+
[source, console]
----
kubectl apply -f astracontrol-clusterrolebinding.yaml
----


. Creare e applicare il token secret:
+
.. Creare un file token secret chiamato `secret-astracontrol-service-account.yaml`.
+
[source, subs="specialcharacters,quotes"]
----
*secret-astracontrol-service-account.yaml*
----
+
[source, yaml]
----
apiVersion: v1
kind: Secret
metadata:
  name: secret-astracontrol-service-account
  namespace: default
  annotations:
    kubernetes.io/service-account.name: "astracontrol-service-account"
type: kubernetes.io/service-account-token
----
.. Applicare il token secret:
+
[source, console]
----
kubectl apply -f secret-astracontrol-service-account.yaml
----


. Aggiungere il token secret all'account del servizio aggiungendo il nome a `secrets` array (l'ultima riga dell'esempio seguente):
+
[source, console]
----
kubectl edit sa astracontrol-service-account
----
+
[source, subs="verbatim,quotes"]
----
apiVersion: v1
imagePullSecrets:
- name: astracontrol-service-account-dockercfg-48xhx
kind: ServiceAccount
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","kind":"ServiceAccount","metadata":{"annotations":{},"name":"astracontrol-service-account","namespace":"default"}}
  creationTimestamp: "2023-06-14T15:25:45Z"
  name: astracontrol-service-account
  namespace: default
  resourceVersion: "2767069"
  uid: 2ce068c4-810e-4a96-ada3-49cbf9ec3f89
secrets:
- name: astracontrol-service-account-dockercfg-48xhx
*- name: secret-astracontrol-service-account*
----
. Elencare i segreti dell'account di servizio, sostituendo `<CONTEXT>` con il contesto corretto per l'installazione:
+
[source, console]
----
kubectl get serviceaccount astracontrol-service-account --context <CONTEXT> --namespace default -o json
----
+
La fine dell'output dovrebbe essere simile a quanto segue:

+
[listing]
----
"secrets": [
{ "name": "astracontrol-service-account-dockercfg-48xhx"},
{ "name": "secret-astracontrol-service-account"}
]
----
+
Gli indici di ciascun elemento in `secrets` l'array inizia con 0. Nell'esempio precedente, l'indice per `astracontrol-service-account-dockercfg-48xhx` sarebbe 0 e l'indice per `secret-astracontrol-service-account` sarebbe 1. Nell'output, annotare il numero dell'indice per il segreto dell'account del servizio. Questo numero di indice sarà necessario nella fase successiva.

. Generare il kubeconfig come segue:
+
.. Creare un `create-kubeconfig.sh` file. Sostituire `TOKEN_INDEX` all'inizio del seguente script con il valore corretto.
+
[source, subs="specialcharacters,quotes"]
----
*create-kubeconfig.sh*
----
+
[source, bash]
----
# Update these to match your environment.
# Replace TOKEN_INDEX with the correct value
# from the output in the previous step. If you
# didn't change anything else above, don't change
# anything else here.

SERVICE_ACCOUNT_NAME=astracontrol-service-account
NAMESPACE=default
NEW_CONTEXT=astracontrol
KUBECONFIG_FILE='kubeconfig-sa'

CONTEXT=$(kubectl config current-context)

SECRET_NAME=$(kubectl get serviceaccount ${SERVICE_ACCOUNT_NAME} \
  --context ${CONTEXT} \
  --namespace ${NAMESPACE} \
  -o jsonpath='{.secrets[TOKEN_INDEX].name}')
TOKEN_DATA=$(kubectl get secret ${SECRET_NAME} \
  --context ${CONTEXT} \
  --namespace ${NAMESPACE} \
  -o jsonpath='{.data.token}')

TOKEN=$(echo ${TOKEN_DATA} | base64 -d)

# Create dedicated kubeconfig
# Create a full copy
kubectl config view --raw > ${KUBECONFIG_FILE}.full.tmp

# Switch working context to correct context
kubectl --kubeconfig ${KUBECONFIG_FILE}.full.tmp config use-context ${CONTEXT}

# Minify
kubectl --kubeconfig ${KUBECONFIG_FILE}.full.tmp \
  config view --flatten --minify > ${KUBECONFIG_FILE}.tmp

# Rename context
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  rename-context ${CONTEXT} ${NEW_CONTEXT}

# Create token user
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  set-credentials ${CONTEXT}-${NAMESPACE}-token-user \
  --token ${TOKEN}

# Set context to use token user
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  set-context ${NEW_CONTEXT} --user ${CONTEXT}-${NAMESPACE}-token-user

# Set context to correct namespace
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  set-context ${NEW_CONTEXT} --namespace ${NAMESPACE}

# Flatten/minify kubeconfig
kubectl config --kubeconfig ${KUBECONFIG_FILE}.tmp \
  view --flatten --minify > ${KUBECONFIG_FILE}

# Remove tmp
rm ${KUBECONFIG_FILE}.full.tmp
rm ${KUBECONFIG_FILE}.tmp
----
.. Eseguire la sorgente dei comandi per applicarli al cluster Kubernetes.
+
[source, console]
----
source create-kubeconfig.sh
----


. (Facoltativo) rinominare il kubeconfig con un nome significativo per il cluster.
+
[listing]
----
mv kubeconfig-sa YOUR_CLUSTER_NAME_kubeconfig
----

